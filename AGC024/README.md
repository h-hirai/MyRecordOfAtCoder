# AtCoder Grand Contest 024

2018-05-20参加。A, B, C問題AC。これより前のAGCでは1問も解けたことがなかったの対して、いきなりこの出来でレートもいっきに上がった奇跡の回。2017-07-21現在でもこのときパフォーマンス以上を出せていない。

[提出一覧](https://atcoder.jp/contests/agc024/submissions?f.User=hhirai)

## A. Fairness

[問題ページ](https://atcoder.jp/contests/agc024/tasks/agc024_a)

A, B, Cに対してK回操作を繰り返した後でA-Bを求める。

実際に何回か分の操作をシミュレーションしてみると、Kが奇数のとき答えは`B-A`、偶数のときは`A-B`になることがわかる。

## B. Backfront

[問題ページ](https://atcoder.jp/contests/agc024/tasks/agc024_b)

選択ソート (のようななにか) に必要な操作回数を求める。

ソート済みの部分については操作が必要ないので、与えられた数列の中からソート済みの部分で最長のものを見つける。たとえば`(2, 5, 3, 6, 4, 1)`であれば、`(2, 3, 4)`、`(5, 6)`がそれぞれソート済みであるが、`(2, 3, 4)`のほうが長いので、1, 5, 6を順に選択し、`(2, 3, 4)`の両端に移動することでソートが完了する。よって答えは3になる。

ソート済み列の長さを求めるには、長さ N+1 の 0 で初期化された配列 A を用意し、P_i が入力されるたびに A[P_i] に A[P_i-1]+1 を入れればよい。つまり、入力された P_i の1つ前の値がすでに入力済みであれば、それはソート済み列の一部である。こうしてできた A の最大値が、最長のソート済み列の長さになる。

## C. Sequence Growing Easy

[問題ページ](https://atcoder.jp/contests/agc024/tasks/agc024_c)

与えられた数列を、決められた操作の繰り返しで作成できるかを判定し、可能な場合の最小操作回数を求める。

作成できる数列は、0から1ずつ階段状に増加する列か、それを上書きしたもの、なので、

- インデックスより大きい値があるときは作成不可能
- 前の数より2以上大きい値があるときは作成不可能
- 前の数より1大きい値があるときは操作回数を +1
- 前の数以下の値があるときは、そこまで階段状に列を作った後でそれより前を上書きした部分なので、その値分だけ操作回数を増加
